<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/magicwand.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/magicwand.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * OpenSeadragon paperjs overlay plugin based on paper.js
 * @version 0.4.2
 * 
 * Includes additional open source libraries which are subject to copyright notices
 * as indicated accompanying those segments of code.
 * 
 * Original code:
 * Copyright (c) 2022-2024, Thomas Pearce
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of osd-paperjs-annotation nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

////// MagicWand.js
    // https://github.com/Tamersoul/magic-wand-js a3b0903 last modified Oct 13, 2020, downloaded 9/21/21 
    // The MIT License (MIT)

    // Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)

    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:

    // The above copyright notice and this permission notice shall be included in all
    // copies or substantial portions of the Software.

    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    // SOFTWARE.
    
    
    export function makeMagicWand() {
        var lib = {};
    
        /** Create a binary mask on the image by color threshold
         * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)
         * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes
         * @param {int} x of start pixel
         * @param {int} y of start pixel
         * @param {int} color threshold
         * @param {Uint8Array} mask of visited points (optional) 
         * @param {boolean} [includeBorders=false] indicate whether to include borders pixels
         * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
         */
        lib.floodFill = function(image, px, py, colorThreshold, mask, includeBorders) {
            return includeBorders
                ? floodFillWithBorders(image, px, py, colorThreshold, mask)
                : floodFillWithoutBorders(image, px, py, colorThreshold, mask);
        };
    
        function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {
    
            var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,
                data = image.data,
                w = image.width,
                h = image.height,
                bytes = image.bytes, // number of bytes in the color
                maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,
                i = py * w + px, // start point index in the mask data
                result = new Uint8Array(w * h), // result mask
                visited = new Uint8Array(mask ? mask : w * h); // mask of visited points
    
            if (visited[i] === 1) return null;
    
            i = i * bytes; // start point index in the image data
            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)
    
            var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line
            do {
                el = stack.shift(); // get line for scanning
    
                checkY = false;
                for (x = el.left + 1; x &lt; el.right; x++) {
                    dy = el.y * w;
                    i = (dy + x) * bytes; // point index in the image data
    
                    if (visited[dy + x] === 1) continue; // check whether the point has been visited
                    
                    // compare the color of the sample
                    c = data[i] - sampleColor[0]; // check by red
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;
                    c = data[i + 1] - sampleColor[1]; // check by green
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;
                    c = data[i + 2] - sampleColor[2]; // check by blue
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;
                    
                    //ignore transparent points
                    if(data[i+3] === 0) continue;
    
                    checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y 
    
                    result[dy + x] = 1; // mark a new point in mask
                    visited[dy + x] = 1; // mark a new point as visited
    
                    xl = x - 1;
                    // walk to left side starting with the left neighbor
                    while (xl > -1) {
                        dyl = dy + xl;
                        i = dyl * bytes; // point index in the image data
                        if (visited[dyl] === 1) break; // check whether the point has been visited
                        // compare the color of the sample
                        c = data[i] - sampleColor[0]; // check by red
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 1] - sampleColor[1]; // check by green
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 2] - sampleColor[2]; // check by blue
                        if (c > colorThreshold || c &lt; -colorThreshold) break;

                        //ignore transparent points
                        if(data[i+3] === 0) break;
    
                        result[dyl] = 1;
                        visited[dyl] = 1;
    
                        xl--;
                    }
                    xr = x + 1;
                    // walk to right side starting with the right neighbor
                    while (xr &lt; w) {
                        dyr = dy + xr;
                        i = dyr * bytes; // index point in the image data
                        if (visited[dyr] === 1) break; // check whether the point has been visited
                        // compare the color of the sample
                        c = data[i] - sampleColor[0]; // check by red
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 1] - sampleColor[1]; // check by green
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 2] - sampleColor[2]; // check by blue
                        if (c > colorThreshold || c &lt; -colorThreshold) break;

                        //ignore transparent points
                        if(data[i+3] === 0) break;
    
                        result[dyr] = 1;
                        visited[dyr] = 1;
    
                        xr++;
                    }
    
                    // check minmax for X
                    if (xl &lt; minX) minX = xl + 1;
                    if (xr > maxX) maxX = xr - 1;
    
                    newY = el.y - el.dir;
                    if (newY >= 0 &amp;&amp; newY &lt; h) { // add two scanning lines in the opposite direction (y - dir) if necessary
                        if (xl &lt; el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from "new left" to "current left"
                        if (el.right &lt; xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from "current right" to "new right"
                    }
                    newY = el.y + el.dir;
                    if (newY >= 0 &amp;&amp; newY &lt; h) { // add the scanning line in the direction (y + dir) if necessary
                        if (xl &lt; xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from "new left" to "new right"
                    }
                }
                // check minmax for Y if necessary
                if (checkY) {
                    if (el.y &lt; minY) minY = el.y;
                    if (el.y > maxY) maxY = el.y;
                }
            } while (stack.length > 0);
    
            return {
                data: result,
                width: image.width,
                height: image.height,
                bounds: {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                },
                sampleColor:sampleColor,
            };
        };
    
        function floodFillWithBorders(image, px, py, colorThreshold, mask) {
    
            var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,
                data = image.data,
                w = image.width,
                h = image.height,
                bytes = image.bytes, // number of bytes in the color
                maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,
                i = py * w + px, // start point index in the mask data
                result = new Uint8Array(w * h), // result mask
                visited = new Uint8Array(mask ? mask : w * h); // mask of visited points
    
            if (visited[i] === 1) return null;
    
            i = i * bytes; // start point index in the image data
            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)
    
            var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line
            do {
                el = stack.shift(); // get line for scanning
    
                checkY = false;
                for (x = el.left + 1; x &lt; el.right; x++) {
                    dy = el.y * w;
                    i = (dy + x) * bytes; // point index in the image data
    
                    if (visited[dy + x] === 1) continue; // check whether the point has been visited
    
                    checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y 
    
                    result[dy + x] = 1; // mark a new point in mask
                    visited[dy + x] = 1; // mark a new point as visited

                    // compare the color of the sample
                    c = data[i] - sampleColor[0]; // check by red
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;
                    c = data[i + 1] - sampleColor[1]; // check by green
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;
                    c = data[i + 2] - sampleColor[2]; // check by blue
                    if (c > colorThreshold || c &lt; -colorThreshold) continue;

                    //ignore transparent points
                    if(data[i+3] === 0) continue;
    
                    xl = x - 1;
                    // walk to left side starting with the left neighbor
                    while (xl > -1) {
                        dyl = dy + xl;
                        i = dyl * bytes; // point index in the image data
                        if (visited[dyl] === 1) break; // check whether the point has been visited
    
                        result[dyl] = 1;
                        visited[dyl] = 1;
                        xl--;
    
                        // compare the color of the sample
                        c = data[i] - sampleColor[0]; // check by red
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 1] - sampleColor[1]; // check by green
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 2] - sampleColor[2]; // check by blue
                        if (c > colorThreshold || c &lt; -colorThreshold) break;

                        //ignore transparent points
                        if(data[i+3] === 0) break;
                    }
                    xr = x + 1;
                    // walk to right side starting with the right neighbor
                    while (xr &lt; w) {
                        dyr = dy + xr;
                        i = dyr * bytes; // index point in the image data
                        if (visited[dyr] === 1) break; // check whether the point has been visited
    
                        result[dyr] = 1;
                        visited[dyr] = 1;
                        xr++;
    
                        // compare the color of the sample
                        c = data[i] - sampleColor[0]; // check by red
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 1] - sampleColor[1]; // check by green
                        if (c > colorThreshold || c &lt; -colorThreshold) break;
                        c = data[i + 2] - sampleColor[2]; // check by blue
                        if (c > colorThreshold || c &lt; -colorThreshold) break;

                        //ignore transparent points
                        if(data[i+3] === 0) break;
                    }
    
                    // check minmax for X
                    if (xl &lt; minX) minX = xl + 1;
                    if (xr > maxX) maxX = xr - 1;
    
                    newY = el.y - el.dir;
                    if (newY >= 0 &amp;&amp; newY &lt; h) { // add two scanning lines in the opposite direction (y - dir) if necessary
                        if (xl &lt; el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from "new left" to "current left"
                        if (el.right &lt; xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from "current right" to "new right"
                    }
                    newY = el.y + el.dir;
                    if (newY >= 0 &amp;&amp; newY &lt; h) { // add the scanning line in the direction (y + dir) if necessary
                        if (xl &lt; xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from "new left" to "new right"
                    }
                }
                // check minmax for Y if necessary
                if (checkY) {
                    if (el.y &lt; minY) minY = el.y;
                    if (el.y > maxY) maxY = el.y;
                }
            } while (stack.length > 0);
    
            return {
                data: result,
                width: image.width,
                height: image.height,
                bounds: {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                },
                sampleColor:sampleColor,
            };
        };
    
        lib.thresholdMask = function(image, px, py, colorThreshold, masks={}) {
    
            let c, r,
                data = image.data,
                w = image.width,
                h = image.height,
                bytes = image.bytes, // number of bytes in the color
                i = py * w + px, // start point index in the mask data
                result = new Uint8Array(masks.append ? masks.append :w * h), // result mask
                ignore = new Uint8Array(masks.ignore ? masks.ignore : w * h); // mask of points to ignore
    
            if (ignore[i] === 1) return null;
    
            i = i * bytes; // start point index in the image data
            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)
            
            for(i = 0, r = 0; i&lt;data.length; i+=4, r+=1){
                if(ignore[r] || result[r]) continue;

                //ignore transparent points
                if(data[i+3] === 0) continue;

                // compare the color of the sample
                c = data[i] - sampleColor[0]; // check by red
                if (c > colorThreshold || c &lt; -colorThreshold) continue;
                c = data[i + 1] - sampleColor[1]; // check by green
                if (c > colorThreshold || c &lt; -colorThreshold) continue;
                c = data[i + 2] - sampleColor[2]; // check by blue
                if (c > colorThreshold || c &lt; -colorThreshold) continue;
    
                result[r]=1;
    
            }
    
            return {
                data: result,
                width: image.width,
                height: image.height,
                bounds: {
                    minX: 0,
                    minY: 0,
                    maxX: w,
                    maxY: h
                },
                sampleColor:sampleColor,
            };
        };
    
    
        /** Apply the gauss-blur filter to binary mask
            * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html
            * http://www.librow.com/articles/article-9
            * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @param {int} blur radius
            * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            */
        lib.gaussBlur = function(mask, radius) {
    
            var i, k, k1, x, y, val, start, end,
                n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)
                s2 = radius * radius,
                wg = new Float32Array(n), // weights
                total = 0, // sum of weights(used for normalization)
                w = mask.width,
                h = mask.height,
                data = mask.data,
                minX = mask.bounds.minX,
                maxX = mask.bounds.maxX,
                minY = mask.bounds.minY,
                maxY = mask.bounds.maxY;
    
            // calc gauss weights
            for (i = 0; i &lt; radius; i++) {
                var dsq = (radius - i) * (radius - i);
                var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);
                wg[radius + i] = wg[radius - i] = ww;
                total += 2 * ww;
            }
            // normalization weights
            for (i = 0; i &lt; n; i++) {
                wg[i] /= total;
            }
    
            var result = new Uint8Array(w * h), // result mask
                endX = radius + w,
                endY = radius + h;
    
            //walk through all source points for blur
            for (y = minY; y &lt; maxY + 1; y++)
                for (x = minX; x &lt; maxX + 1; x++) {
                    val = 0;
                    k = y * w + x; // index of the point
                    start = radius - x > 0 ? radius - x : 0;
                    end = endX - x &lt; n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);
                    k1 = k - radius;
                    // walk through x-neighbors
                    for (i = start; i &lt; end; i++) {
                        val += data[k1 + i] * wg[i];
                    }
                    start = radius - y > 0 ? radius - y : 0;
                    end = endY - y &lt; n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);
                    k1 = k - radius * w;
                    // walk through y-neighbors
                    for (i = start; i &lt; end; i++) {
                        val += data[k1 + i * w] * wg[i];
                    }
                    result[k] = val > 0.5 ? 1 : 0;
                }
    
            return {
                data: result,
                width: w,
                height: h,
                bounds: {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                }
            };
        };
    
        /** Create a border index array of boundary points of the mask with radius-neighbors
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @param {int} blur radius
            * @param {Uint8Array} visited: mask of visited points (optional) 
            * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)
            */
        function createBorderForBlur(mask, radius, visited) {
    
            var x, i, j, y, k, k1, k2,
                w = mask.width,
                h = mask.height,
                data = mask.data,
                visitedData = new Uint8Array(data),
                minX = mask.bounds.minX,
                maxX = mask.bounds.maxX,
                minY = mask.bounds.minY,
                maxY = mask.bounds.maxY,
                len = w * h,
                temp = new Uint8Array(len), // auxiliary array to check uniqueness
                border = [], // only border points
                x0 = Math.max(minX, 1),
                x1 = Math.min(maxX, w - 2),
                y0 = Math.max(minY, 1),
                y1 = Math.min(maxY, h - 2);
    
            if (visited &amp;&amp; visited.length > 0) {
                // copy visited points (only "black")
                for (k = 0; k &lt; len; k++) {
                    if (visited[k] === 1) visitedData[k] = 1;
                }
            }
    
            // walk through inner values except points on the boundary of the image
            for (y = y0; y &lt; y1 + 1; y++)
                for (x = x0; x &lt; x1 + 1; x++) {
                    k = y * w + x;
                    if (data[k] === 0) continue; // "white" point isn't the border
                    k1 = k + w; // y + 1
                    k2 = k - w; // y - 1
                    // check if any neighbor with a "white" color
                    if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||
                        visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||
                        visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {
                        //if (visitedData[k + 1] + visitedData[k - 1] + 
                        //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +
                        //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;
                        border.push(k);
                    }
                }
    
            // walk through points on the boundary of the image if necessary
            // if the "black" point is adjacent to the boundary of the image, it is a border point
            if (minX == 0)
                for (y = minY; y &lt; maxY + 1; y++)
                    if (data[y * w] === 1)
                        border.push(y * w);
    
            if (maxX == w - 1)
                for (y = minY; y &lt; maxY + 1; y++)
                    if (data[y * w + maxX] === 1)
                        border.push(y * w + maxX);
    
            if (minY == 0)
                for (x = minX; x &lt; maxX + 1; x++)
                    if (data[x] === 1)
                        border.push(x);
    
            if (maxY == h - 1)
                for (x = minX; x &lt; maxX + 1; x++)
                    if (data[maxY * w + x] === 1)
                        border.push(maxY * w + x);
    
            var result = [], // border points with radius-neighbors
                start, end,
                endX = radius + w,
                endY = radius + h,
                n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)
    
            len = border.length;
            // walk through radius-neighbors of border points and add them to the result array
            for (j = 0; j &lt; len; j++) {
                k = border[j]; // index of the border point
                temp[k] = 1; // mark border point
                result.push(k); // save the border point
                x = k % w; // calc x by index
                y = (k - x) / w; // calc y by index
                start = radius - x > 0 ? radius - x : 0;
                end = endX - x &lt; n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);
                k1 = k - radius;
                // walk through x-neighbors
                for (i = start; i &lt; end; i++) {
                    k2 = k1 + i;
                    if (temp[k2] === 0) { // check the uniqueness
                        temp[k2] = 1;
                        result.push(k2);
                    }
                }
                start = radius - y > 0 ? radius - y : 0;
                end = endY - y &lt; n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);
                k1 = k - radius * w;
                // walk through y-neighbors
                for (i = start; i &lt; end; i++) {
                    k2 = k1 + i * w;
                    if (temp[k2] === 0) { // check the uniqueness
                        temp[k2] = 1;
                        result.push(k2);
                    }
                }
            }
    
            return result;
        };
    
        /** Apply the gauss-blur filter ONLY to border points with radius-neighbors
            * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html
            * http://www.librow.com/articles/article-9
            * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @param {int} blur radius
            * @param {Uint8Array} visited: mask of visited points (optional) 
            * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            */
        lib.gaussBlurOnlyBorder = function(mask, radius, visited) {
    
            var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors
                ww, dsq, i, j, k, k1, x, y, val, start, end,
                n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)
                s2 = 2 * radius * radius,
                wg = new Float32Array(n), // weights
                total = 0, // sum of weights(used for normalization)
                w = mask.width,
                h = mask.height,
                data = mask.data,
                minX = mask.bounds.minX,
                maxX = mask.bounds.maxX,
                minY = mask.bounds.minY,
                maxY = mask.bounds.maxY,
                len = border.length;
    
            // calc gauss weights
            for (i = 0; i &lt; radius; i++) {
                dsq = (radius - i) * (radius - i);
                ww = Math.exp(-dsq / s2) / Math.PI;
                wg[radius + i] = wg[radius - i] = ww;
                total += 2 * ww;
            }
            // normalization weights
            for (i = 0; i &lt; n; i++) {
                wg[i] /= total;
            }
    
            var result = new Uint8Array(data), // copy the source mask
                endX = radius + w,
                endY = radius + h;
    
            //walk through all border points for blur
            for (i = 0; i &lt; len; i++) {
                k = border[i]; // index of the border point
                val = 0;
                x = k % w; // calc x by index
                y = (k - x) / w; // calc y by index
                start = radius - x > 0 ? radius - x : 0;
                end = endX - x &lt; n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);
                k1 = k - radius;
                // walk through x-neighbors
                for (j = start; j &lt; end; j++) {
                    val += data[k1 + j] * wg[j];
                }
                if (val > 0.5) {
                    result[k] = 1;
                    // check minmax
                    if (x &lt; minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y &lt; minY) minY = y;
                    if (y > maxY) maxY = y;
                    continue;
                }
                start = radius - y > 0 ? radius - y : 0;
                end = endY - y &lt; n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);
                k1 = k - radius * w;
                // walk through y-neighbors
                for (j = start; j &lt; end; j++) {
                    val += data[k1 + j * w] * wg[j];
                }
                if (val > 0.5) {
                    result[k] = 1;
                    // check minmax
                    if (x &lt; minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y &lt; minY) minY = y;
                    if (y > maxY) maxY = y;
                } else {
                    result[k] = 0;
                }
            }
    
            return {
                data: result,
                width: w,
                height: h,
                bounds: {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                }
            };
        };
    
        /** Create a border mask (only boundary points)
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset
            */
        lib.createBorderMask = function(mask) {
    
            var x, y, k, k1, k2,
                w = mask.width,
                h = mask.height,
                data = mask.data,
                minX = mask.bounds.minX,
                maxX = mask.bounds.maxX,
                minY = mask.bounds.minY,
                maxY = mask.bounds.maxY,
                rw = maxX - minX + 1, // bounds size
                rh = maxY - minY + 1,
                result = new Uint8Array(rw * rh), // reduced mask (bounds size)
                x0 = Math.max(minX, 1),
                x1 = Math.min(maxX, w - 2),
                y0 = Math.max(minY, 1),
                y1 = Math.min(maxY, h - 2);
    
            // walk through inner values except points on the boundary of the image
            for (y = y0; y &lt; y1 + 1; y++)
                for (x = x0; x &lt; x1 + 1; x++) {
                    k = y * w + x;
                    if (data[k] === 0) continue; // "white" point isn't the border
                    k1 = k + w; // y + 1
                    k2 = k - w; // y - 1
                    // check if any neighbor with a "white" color
                    if (data[k + 1] === 0 || data[k - 1] === 0 ||
                        data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||
                        data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {
                        //if (data[k + 1] + data[k - 1] + 
                        //    data[k1] + data[k1 + 1] + data[k1 - 1] +
                        //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;
                        result[(y - minY) * rw + (x - minX)] = 1;
                    }
                }
    
            // walk through points on the boundary of the image if necessary
            // if the "black" point is adjacent to the boundary of the image, it is a border point
            if (minX == 0)
                for (y = minY; y &lt; maxY + 1; y++)
                    if (data[y * w] === 1)
                        result[(y - minY) * rw] = 1;
    
            if (maxX == w - 1)
                for (y = minY; y &lt; maxY + 1; y++)
                    if (data[y * w + maxX] === 1)
                        result[(y - minY) * rw + (maxX - minX)] = 1;
    
            if (minY == 0)
                for (x = minX; x &lt; maxX + 1; x++)
                    if (data[x] === 1)
                        result[x - minX] = 1;
    
            if (maxY == h - 1)
                for (x = minX; x &lt; maxX + 1; x++)
                    if (data[maxY * w + x] === 1)
                        result[(maxY - minY) * rw + (x - minX)] = 1;
    
            return {
                data: result,
                width: rw,
                height: rh,
                offset: { x: minX, y: minY }
            };
        };
        
        /** Create a border index array of boundary points of the mask
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height
            * @return {Array} border index array boundary points of the mask
            */
        lib.getBorderIndices = function(mask) {
    
            var x, y, k, k1, k2,
                w = mask.width,
                h = mask.height,
                data = mask.data,
                border = [], // only border points
                x1 = w - 1,
                y1 = h - 1;
    
            // walk through inner values except points on the boundary of the image
            for (y = 1; y &lt; y1; y++)
                for (x = 1; x &lt; x1; x++) {
                    k = y * w + x;
                    if (data[k] === 0) continue; // "white" point isn't the border
                    k1 = k + w; // y + 1
                    k2 = k - w; // y - 1
                    // check if any neighbor with a "white" color
                    if (data[k + 1] === 0 || data[k - 1] === 0 ||
                        data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||
                        data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {
                        //if (data[k + 1] + data[k - 1] + 
                        //    data[k1] + data[k1 + 1] + data[k1 - 1] +
                        //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;
                        border.push(k);
                    }
                }
    
            // walk through points on the boundary of the image if necessary
            // if the "black" point is adjacent to the boundary of the image, it is a border point
            for (y = 0; y &lt; h; y++)
                if (data[y * w] === 1)
                    border.push(y * w);
    
            for (x = 0; x &lt; w; x++)
                if (data[x] === 1)
                    border.push(x);
    
            k = w - 1;
            for (y = 0; y &lt; h; y++)
                if (data[y * w + k] === 1)
                    border.push(y * w + k);
    
            k = (h - 1) * w;
            for (x = 0; x &lt; w; x++)
                if (data[k + x] === 1)
                    border.push(k + x);
    
            return border;
        };
        
        /** Create a compressed mask with a "white" border (1px border with zero values) for the contour tracing
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset
            */
        function prepareMask(mask) {
            var x, y,
                w = mask.width,
                data = mask.data,
                minX = mask.bounds.minX,
                maxX = mask.bounds.maxX,
                minY = mask.bounds.minY,
                maxY = mask.bounds.maxY,
                rw = maxX - minX + 3, // bounds size +1 px on each side (a "white" border)
                rh = maxY - minY + 3,
                result = new Uint8Array(rw * rh); // reduced mask (bounds size)
    
            // walk through inner values and copy only "black" points to the result mask
            for (y = minY; y &lt; maxY + 1; y++)
                for (x = minX; x &lt; maxX + 1; x++) {
                    if (data[y * w + x] === 1)
                        result[(y - minY + 1) * rw + (x - minX + 1)] = 1;
                }
    
            return {
                data: result,
                width: rw,
                height: rh,
                offset: { x: minX - 1, y: minY - 1 }
            };
        };
            
        /** Create a contour array for the binary mask
            * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401
            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds
            * @return {Array} contours: {Array} points, {bool} inner, {int} label
            */
        lib.traceContours = function(mask) {
            var m = prepareMask(mask),
                contours = [],
                label = 0,
                w = m.width,
                w2 = w * 2,
                h = m.height,
                src = m.data,
                dx = m.offset.x,
                dy = m.offset.y,
                dest = new Uint8Array(src), // label matrix
                i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;
    
            // all [dx,dy] pairs (array index is the direction)
            // 5 6 7
            // 4 X 0
            // 3 2 1
            var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];
    
            for (y = 1; y &lt; h - 1; y++)
                for (x = 1; x &lt; w - 1; x++) {
                    k = y * w + x;
                    if (src[k] === 1) {
                        for (i = -w; i &lt; w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)
                            if (src[k + i] === 0 &amp;&amp; dest[k + i] === 0) { // need contour tracing
                                inner = i === w; // is inner contour tracing ?
                                label++; // label for the next contour
    
                                c = [];
                                dir = inner ? 2 : 6; // start direction
                                current = previous = first = { x: x, y: y };
                                second = null;
                                while (true) {
                                    dest[current.y * w + current.x] = label; // mark label for the current point 
                                    // bypass all the neighbors around the current point in a clockwise
                                    for (j = 0; j &lt; 8; j++) {
                                        dir = (dir + 1) % 8;
    
                                        // get the next point by new direction
                                        d = directions[dir]; // index as direction
                                        next = { x: current.x + d[0], y: current.y + d[1] };
    
                                        k1 = next.y * w + next.x;
                                        if (src[k1] === 1) // black boundary pixel
                                        {
                                            dest[k1] = label; // mark a label
                                            break;
                                        }
                                        dest[k1] = -1; // mark a white boundary pixel
                                        next = null;
                                    }
                                    if (next === null) break; // no neighbours (one-point contour)
                                    current = next;
                                    if (second) {
                                        if (previous.x === first.x &amp;&amp; previous.y === first.y &amp;&amp; current.x === second.x &amp;&amp; current.y === second.y) {
                                            break; // creating the contour completed when returned to original position
                                        }
                                    } else {
                                        second = next;
                                    }
                                    c.push({ x: previous.x + dx, y: previous.y + dy });
                                    previous = current;
                                    dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)
                                }
    
                                if (next != null) {
                                    c.push({ x: first.x + dx, y: first.y + dy }); // close the contour
                                    contours.push({ inner: inner, label: label, points: c }); // add contour to the list
                                }
                            }
                        }
                    }
                }
    
            return contours;
        };
        
        /** Simplify contours
            * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html 
            * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8
            * @param {Array} contours: {Array} points, {bool} inner, {int} label
            * @param {float} simplify tolerant
            * @param {int} simplify count: min number of points when the contour is simplified
            * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount
            */
        lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {
            var lenContours = contours.length,
                result = [],
                i, j, k, c, points, len, resPoints, lst, stack, ids,
                maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;
    
            // walk through all contours 
            for (j = 0; j &lt; lenContours; j++) {
                c = contours[j];
                points = c.points;
                len = c.points.length;
    
                if (len &lt; simplifyCount) { // contour isn't simplified
                    resPoints = [];
                    for (k = 0; k &lt; len; k++) {
                        resPoints.push({ x: points[k].x, y: points[k].y });
                    }
                    result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });
                    continue;
                }
    
                lst = [0, len - 1]; // always add first and last points
                stack = [{ first: 0, last: len - 1 }]; // first processed edge
    
                do {
                    ids = stack.shift();
                    if (ids.last &lt;= ids.first + 1) // no intermediate points
                    {
                        continue;
                    }
    
                    maxd = -1.0; // max distance from point to current edge
                    maxi = ids.first; // index of maximally distant point
    
                    for (i = ids.first + 1; i &lt; ids.last; i++) // bypass intermediate points in edge
                    {
                        // calc the distance from current point to edge
                        pi = points[i];
                        pf = points[ids.first];
                        pl = points[ids.last];
                        dx = pi.x - pf.x;
                        dy = pi.y - pf.y;
                        r1 = Math.sqrt(dx * dx + dy * dy);
                        dx = pi.x - pl.x;
                        dy = pi.y - pl.y;
                        r2 = Math.sqrt(dx * dx + dy * dy);
                        dx = pf.x - pl.x;
                        dy = pf.y - pl.y;
                        r12 = Math.sqrt(dx * dx + dy * dy);
                        if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;
                        else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;
                        else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);
    
                        if (dist > maxd) {
                            maxi = i; // save the index of maximally distant point
                            maxd = dist;
                        }
                    }
    
                    if (maxd > simplifyTolerant) // if the max "deviation" is larger than allowed then...
                    {
                        lst.push(maxi); // add index to the simplified list
                        stack.push({ first: ids.first, last: maxi }); // add the left part for processing
                        stack.push({ first: maxi, last: ids.last }); // add the right part for processing
                    }
    
                } while (stack.length > 0);
    
                resPoints = [];
                len = lst.length;
                lst.sort(function(a, b) { return a - b; }); // restore index order
                for (k = 0; k &lt; len; k++) {
                    resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order
                }
                result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });
            }
    
            return result;
        };
        
    
        return lib;
    };
    </code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="OSDPaperjsAnnotation.html">OSDPaperjsAnnotation</a></li></ul><h3>Classes</h3><ul><li><a href="Dialog.html">Dialog</a></li><li><a href="DragAndDrop.html">DragAndDrop</a></li><li><a href="EditableContent.html">EditableContent</a></li><li><a href="Morph.html">Morph</a></li><li><a href="OSDPaperjsAnnotation.AnnotationItem.html">AnnotationItem</a></li><li><a href="OSDPaperjsAnnotation.AnnotationItemFactory.html">AnnotationItemFactory</a></li><li><a href="OSDPaperjsAnnotation.AnnotationToolbar.html">AnnotationToolbar</a></li><li><a href="OSDPaperjsAnnotation.AnnotationToolkit.html">AnnotationToolkit</a></li><li><a href="OSDPaperjsAnnotation.AnnotationUI.html">AnnotationUI</a></li><li><a href="OSDPaperjsAnnotation.AnnotationUITool.html">AnnotationUITool</a></li><li><a href="OSDPaperjsAnnotation.AnnotationUITool.AnnotationUIToolbarBase.html">AnnotationUIToolbarBase</a></li><li><a href="OSDPaperjsAnnotation.BrushTool.html">BrushTool</a></li><li><a href="OSDPaperjsAnnotation.BrushTool.BrushToolbar.html">BrushToolbar</a></li><li><a href="OSDPaperjsAnnotation.DefaultTool.html">DefaultTool</a></li><li><a href="OSDPaperjsAnnotation.DefaultTool.DefaultToolbar.html">DefaultToolbar</a></li><li><a href="OSDPaperjsAnnotation.Ellipse.html">Ellipse</a></li><li><a href="OSDPaperjsAnnotation.EllipseTool.html">EllipseTool</a></li><li><a href="OSDPaperjsAnnotation.EllipseTool.EllipseToolbar.html">EllipseToolbar</a></li><li><a href="OSDPaperjsAnnotation.FeatureCollectionUI.html">FeatureCollectionUI</a></li><li><a href="OSDPaperjsAnnotation.FeatureUI.html">FeatureUI</a></li><li><a href="OSDPaperjsAnnotation.FileDialog.html">FileDialog</a></li><li><a href="OSDPaperjsAnnotation.LayerUI.html">LayerUI</a></li><li><a href="OSDPaperjsAnnotation.Linestring.html">Linestring</a></li><li><a href="OSDPaperjsAnnotation.LinestringTool.html">LinestringTool</a></li><li><a href="OSDPaperjsAnnotation.LinestringTool.LinestringToolbar.html">LinestringToolbar</a></li><li><a href="OSDPaperjsAnnotation.MultiLinestring.html">MultiLinestring</a></li><li><a href="OSDPaperjsAnnotation.MultiPolygon.html">MultiPolygon</a></li><li><a href="OSDPaperjsAnnotation.PaperOverlay.html">PaperOverlay</a></li><li><a href="OSDPaperjsAnnotation.Placeholder.html">Placeholder</a></li><li><a href="OSDPaperjsAnnotation.Point.html">Point</a></li><li><a href="OSDPaperjsAnnotation.PointText.html">PointText</a></li><li><a href="OSDPaperjsAnnotation.PointTextTool.html">PointTextTool</a></li><li><a href="OSDPaperjsAnnotation.PointTextTool.PointTextToolbar.html">PointTextToolbar</a></li><li><a href="OSDPaperjsAnnotation.PointTool.html">PointTool</a></li><li><a href="OSDPaperjsAnnotation.PointTool.PointToolbar.html">PointToolbar</a></li><li><a href="OSDPaperjsAnnotation.PolygonTool.html">PolygonTool</a></li><li><a href="OSDPaperjsAnnotation.PolygonTool.PolygonToolbar.html">PolygonToolbar</a></li><li><a href="OSDPaperjsAnnotation.Raster.html">Raster</a></li><li><a href="OSDPaperjsAnnotation.RasterTool.html">RasterTool</a></li><li><a href="OSDPaperjsAnnotation.RasterTool.RasterToolbar.html">RasterToolbar</a></li><li><a href="OSDPaperjsAnnotation.Rectangle.html">Rectangle</a></li><li><a href="OSDPaperjsAnnotation.RectangleTool.html">RectangleTool</a></li><li><a href="OSDPaperjsAnnotation.RectangleTool_RectToolbar.html">RectToolbar</a></li><li><a href="OSDPaperjsAnnotation.RotationControlOverlay.html">RotationControlOverlay</a></li><li><a href="OSDPaperjsAnnotation.RotationControlTool.html">RotationControlTool</a></li><li><a href="OSDPaperjsAnnotation.RotationControlWidget.html">RotationControlWidget</a></li><li><a href="OSDPaperjsAnnotation.StyleTool.html">StyleTool</a></li><li><a href="OSDPaperjsAnnotation.StyleTool.StyleToolbar.html">StyleToolbar</a></li><li><a href="OSDPaperjsAnnotation.ToolBase.html">ToolBase</a></li><li><a href="OSDPaperjsAnnotation.TransformTool.html">TransformTool</a></li><li><a href="OSDPaperjsAnnotation.TransformTool.TransformToolbar.html">TransformToolbar</a></li><li><a href="OSDPaperjsAnnotation.WandTool.html">WandTool</a></li><li><a href="OSDPaperjsAnnotation.WandTool.WandToolbar.html">WandToolbar</a></li><li><a href="SelectTool.html">SelectTool</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_paper">_paper</a></li><li><a href="global.html#adaptiveOffsetCurve">adaptiveOffsetCurve</a></li><li><a href="global.html#connectAdjacentBezier">connectAdjacentBezier</a></li><li><a href="global.html#connectBeziers">connectBeziers</a></li><li><a href="global.html#convertFaIcons">convertFaIcons</a></li><li><a href="global.html#getPointLineIntersections">getPointLineIntersections</a></li><li><a href="global.html#iconDefs">iconDefs</a></li><li><a href="global.html#localImportsCompleted">localImportsCompleted</a></li><li><a href="global.html#makeFaIcon">makeFaIcon</a></li><li><a href="global.html#makeRoundJoin">makeRoundJoin</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#offsetSegment">offsetSegment</a></li><li><a href="global.html#osd">osd</a></li><li><a href="global.html#removeIntersection">removeIntersection</a></li><li><a href="global.html#removeOutsiders">removeOutsiders</a></li><li><a href="global.html#updateFillOpacity">updateFillOpacity</a></li><li><a href="global.html#updateStrokeOpacity">updateStrokeOpacity</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Sat Mar 23 2024 06:59:47 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
